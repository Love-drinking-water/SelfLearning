## 1. 面向对象编程

### 1.1 构造方法

初始化类时的方法，类似python的`__init__`方法。

- 如果有多种初始化的方式，可以有多个构造方法，每个构造方法的输入参数或者类型不同。

- 有多个初始化方式时，允许多个构造方法之间的相互调用（通过关键字`this.`）

### 1.2 方法重载

一个类中，多个方法名相同，但各自的参数不同，称为方法重载（`Overload`）。

类似想设置默认值或者不同传入参数可以通过这种方式来写（比起python来说真是麻烦啊，python直接一个函数搞定）

> 方法重载的返回值类型通常都是相同的。

### 1.3 继承

`Student`类集成`Person`类。

在OOP的术语中，我们把`Person`称为超类（super class），父类（parent class），基类（base class），把`Student`称为子类（subclass），扩展类（extended class）。

- Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有`Object`特殊，它没有父类。

- 子类无法访问父类的`private`字段，如果访问，可以将字段更改为`protected`

- 访问父类的属性多数可以通过`super.`或者`this.`获取，但是如果父类有构造方法且存在参数时，此时必须显式的通过关键字`super.`来调用构造方法（默认引用父类构造方法是`super();`）

- 转型

  - 向上转型

    如果`Student`是从`Person`继承下来的，那么`Person p = new Student(); `是正确的，因为子类具备父类的所有功能。

  - 向下转型

    和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）。

    ```java
    Person p1 = new Student(); // upcasting, ok
    Person p2 = new Person();
    Student s1 = (Student) p1; // ok
    Student s2 = (Student) p2; // runtime error! ClassCastException!
    ```

    > 可以通过方法`instanceof`判断，一个类是否是另一个类的子类（类似python的instance）

### 1.4 多态

- `override`和`overload`

  如果方法签名如果不同，就是`overload`，`overload`方法是一个新方法（只不过方法名字相同而已）；如果方法签名相同，并且返回值也相同，就是`override`。

  > 说白了就是override和之前方法的输入、输出、方法名完全一样；而overload只是方法名一样而已。

多态具有一个非常强大的功能，就是**允许添加更多类型的子类实现功能扩展**（实例化的时候呢可以通过向上转型的方式以父类进行示例，所以只需要重写父类的某个个方法即可），却不需要修改基于父类的代码。

- 继承之后，在override时，如果也想利用父类的这个方法，也可以通过`super.`的方式调用。
- 如果不允许override某个方法，可以将方法定义为`final`；类似的原理如果不允许某个类被继承，那就将类定义为`final`；如果希望某个字段不被修改那就将字段定义为`final`。 

### 1.5 抽象类

由于多态的存在，每个子类都可以覆写父类的方法，现实中存在此时父类中的方法没有实际的意义，只是存在的方法名，类似定义的一个规范。此时抽象方法就出现了，知识定义的方法，没有具体的执行逻辑。

当类中包含抽象方法时，类必须为抽象类。抽象类无法被实例化。

**因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。**

但是使用时均是以父类的方式申明。

面向抽象编程的本质就是：

- 上层代码只定义规范（例如：`abstract class Person`）；
- 不需要子类就可以实现业务逻辑（正常编译）；
- 具体的业务逻辑由不同的子类实现，调用者并不关心。

> 有点像强化版的多态

### 1.6 接口

在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。

如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口：`interface`。

所谓`interface`，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是`public abstract`的，所以这两个修饰符不需要写出来（写不写效果都一样）。

可以理解为基于抽象类做了一个更高层的抽象。

> 一个类可以实现多个接口，但是只能继承一个类

后期如果接口需要增加修改时（后面继承的类都要修改），此时可以增加`default`方法，继承的子类不必再重新修改新加入的接口。

> 整体来看，多态、抽象类和接口是一个继承的关系。

### 1.7 静态字段和静态方法

在一个`class`中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。

还有一种字段，是用`static`修饰的字段，称为静态字段，对应的有静态方法。

推荐用类名来访问静态字段。可以把静态字段理解为描述`class`本身的字段（非实例字段）。

静态方法也是不属于实例，可以用类名直接调用，相当于就是个函数（和python是一致的）。

> 之所以称之为静态，估计原因就是他们和实例无关系，只和类有关系。

### 1.8 包

位于同一个包下的class可以直接引用。

如果想引用其它包下的class，使用关键字`import`即可。

### 1.9 classpath和jar包

JVM通过环境变量`classpath`决定搜索`class`的路径和顺序；

不推荐设置系统环境变量`classpath`，始终建议通过`-cp`命令传入（在maven项目里面可以用`.classpath`文件貌似是，没有实操过）；

jar包相当于目录，可以包含很多`.class`文件，方便下载和使用；

`MANIFEST.MF`文件可以提供jar包的信息，如`Main-Class`，这样可以直接运行jar包。

## 2. 

